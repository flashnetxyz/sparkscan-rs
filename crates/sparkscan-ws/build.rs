use std::fs;
use std::path::Path;

fn indent_code(code: &str) -> String {
    code.lines()
        .map(|line| if line.trim().is_empty() { 
            String::new() 
        } else { 
            format!("    {}", line) 
        })
        .collect::<Vec<_>>()
        .join("\n")
}

fn main() {
    println!("cargo:rerun-if-changed=schemas/");

    let out_dir = std::env::var("OUT_DIR").unwrap();
    let dest_path = Path::new(&out_dir).join("types.rs");

    // Read all schema files
    let balance_schema = fs::read_to_string("schemas/balance_schema.json")
        .expect("Failed to read balance_schema.json");
    let token_balance_schema = fs::read_to_string("schemas/token_balance_schema.json")
        .expect("Failed to read token_balance_schema.json");
    let token_price_schema = fs::read_to_string("schemas/token_price_schema.json")
        .expect("Failed to read token_price_schema.json");
    let token_schema =
        fs::read_to_string("schemas/token_schema.json").expect("Failed to read token_schema.json");
    let transaction_schema = fs::read_to_string("schemas/transaction_schema.json")
        .expect("Failed to read transaction_schema.json");

    // Parse schemas into schemars::schema::RootSchema
    let balance_schema: schemars::schema::RootSchema =
        serde_json::from_str(&balance_schema).expect("Failed to parse balance_schema.json");
    let token_balance_schema: schemars::schema::RootSchema =
        serde_json::from_str(&token_balance_schema)
            .expect("Failed to parse token_balance_schema.json");
    let token_price_schema: schemars::schema::RootSchema =
        serde_json::from_str(&token_price_schema).expect("Failed to parse token_price_schema.json");
    let token_schema: schemars::schema::RootSchema =
        serde_json::from_str(&token_schema).expect("Failed to parse token_schema.json");
    let transaction_schema: schemars::schema::RootSchema =
        serde_json::from_str(&transaction_schema).expect("Failed to parse transaction_schema.json");

    // Create TypeSpace settings with enhanced configuration
    let mut settings = typify::TypeSpaceSettings::default();
    settings.with_struct_builder(true); // Enable builder pattern for structs

    // Generate types using typify
    let mut type_space_balance = typify::TypeSpace::new(&settings);
    let mut type_space_token_balance = typify::TypeSpace::new(&settings);
    let mut type_space_token_price = typify::TypeSpace::new(&settings);
    let mut type_space_token = typify::TypeSpace::new(&settings);
    let mut type_space_transaction = typify::TypeSpace::new(&settings);

    // Add schemas to the type space
    type_space_balance
        .add_root_schema(balance_schema)
        .expect("Failed to add balance schema");

    type_space_token_balance
        .add_root_schema(token_balance_schema)
        .expect("Failed to add token balance schema");

    type_space_token_price
        .add_root_schema(token_price_schema)
        .expect("Failed to add token price schema");

    type_space_token
        .add_root_schema(token_schema)
        .expect("Failed to add token schema");

    type_space_transaction
        .add_root_schema(transaction_schema)
        .expect("Failed to add transaction schema");

    // Generate the code with proper error handling
    let generated_code_balance = type_space_balance.to_stream();
    let generated_code_token_balance = type_space_token_balance.to_stream();
    let generated_code_token_price = type_space_token_price.to_stream();
    let generated_code_token = type_space_token.to_stream();
    let generated_code_transaction = type_space_transaction.to_stream();

    let parsed_code_balance = syn::parse2(generated_code_balance)
        .expect("Failed to parse generated code");
    let formatted_code_balance = prettyplease::unparse(&parsed_code_balance);

    let parsed_code_token_balance = syn::parse2(generated_code_token_balance)
        .expect("Failed to parse generated code");
    let formatted_code_token_balance = prettyplease::unparse(&parsed_code_token_balance);

    let parsed_code_token_price = syn::parse2(generated_code_token_price)
        .expect("Failed to parse generated code");
    let formatted_code_token_price = prettyplease::unparse(&parsed_code_token_price);

    let parsed_code_token = syn::parse2(generated_code_token)
        .expect("Failed to parse generated code");
    let formatted_code_token = prettyplease::unparse(&parsed_code_token);

    let parsed_code_transaction = syn::parse2(generated_code_transaction)
        .expect("Failed to parse generated code");
    let formatted_code_transaction = prettyplease::unparse(&parsed_code_transaction);

    let contents = format!(
        "{}\n{}\n\n{}\n\n{}\n\n{}\n\n{}\n\n{}",
        "// This file is generated by build.rs from JSON schemas. Do not edit manually.",
        "// Generated types for SparkScan WebSocket API messages.",
        format!("pub mod balance {{\n{}\n}}", indent_code(&formatted_code_balance)),
        format!("pub mod token_balance {{\n{}\n}}", indent_code(&formatted_code_token_balance)),
        format!("pub mod token_price {{\n{}\n}}", indent_code(&formatted_code_token_price)),
        format!("pub mod token {{\n{}\n}}", indent_code(&formatted_code_token)),
        format!("pub mod transaction {{\n{}\n}}", indent_code(&formatted_code_transaction))
    );

    fs::write(&dest_path, contents).expect("Failed to write generated types");
}
